%{
 #include<stdio.h>
 #include<stdlib.h>
 
 // block datatype is defined to store the identifier and it's type
 struct block  
 {
 char val[20];
 int tval;
 }table[200];
 char storeval[20];
 int  storetval=0;
 int countvar=0; //countvar maintains the number of variables defined
 
 // SandC function takes the identifier name and type (int) and returns void
 void SandC(char k[20],int);
 
 // validatevar funtion takes the identifier name to check if the identifier is defined or not
 int validatevar(char k[20]);
 
 // validate type function takes int ,int as input and return int 
 int validatetype(int,int);
 void checktype(int,int);
 void yyerror(char* s);
 void updatetype(int new);
 
 // The output is printed in output.txt file through yyout 
 FILE* yyout;
 extern int yylineno;
%}
%union {
    char *f;
    int tol;
 }
 
// Taken all tokens generated by the lex file

%token PROGRAM VAR BN END_DOT END REAL
%token INTEGER FOR READ WRITE
%token TO DO SEMI_COLON COLON
%token COMMA EQUAL PLUS MINUS
%token STAR DIV OPENBRACE CLOSEBRACE
%token NO RNO

%token <f> I
%type <tol> t exp tm f as line indexexp

%start p
%%
// Grramer given is taken
p
   : PROGRAM pn VAR dl BN sl END_DOT {printf("%s","Input Accepted");}//Input Accepted is printed on terminal if complete input code parsed
   ;
pn
   : I 
   ;
dl
   : d
   | dl SEMI_COLON d
   | error   { 
                yyerror("");yyerrok;
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a SEMICOLON",yylineno-1);
            } d //syntax error is printed if SEMICOLON is missed between 2 declist
   ;
d
   : idl COLON t
   | idl error t  { 
                yyerror("");yyerrok;
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a COLON",yylineno);
            }
   ;
t
   : INTEGER {$$=1;updatetype(1);} 
   | REAL  {$$=2;updatetype(2);}
   ;
idl
   : I {strcpy(storeval,$1);SandC(storeval,storetval);} //storing and checking every identifier
   | idl COMMA I {strcpy(storeval,$3);SandC(storeval,storetval);} //storing and checking every identifier
   | idl error I { 
                yyerror("");yyerrok;strcpy(storeval,$3);SandC(storeval,storetval);
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a COMMA",yylineno);
            } //syntax error is printed if COMMA is missed between 2 identifiers
   ;
sl
   : stm
   | sl SEMI_COLON stm
   | error  { 
                yyerror("");yyerrok;
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a SEMICOLON",yylineno-1);
            } stm //syntax error is printed if SEMICOLON is missed between 2 statments
   ;
stm
   : as
   | read
   | write
   | for
   ;
as
   : I EQUAL exp {strcpy(storeval,$1);$$=validatevar($1);checktype($$,$3);}
   | I error exp { 
                yyerror("");yyerrok;$$=validatevar($1);checktype($$,$3);
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a EQUAL",yylineno);
            } 
   ;
exp
   : tm {$$=$1;}
   | exp PLUS tm {$$=validatetype($1,$3);}
   | exp MINUS tm {$$=validatetype($1,$3);}
   | exp error tm { 
                yyerror("");yyerrok;
                fprintf(yyout,"\nCHECK LINE NO:%d --> Syntax Error Expecting a Arithematic PLUS OR MINUS",yylineno);
            }
   ;
tm 
   : f {$$=$1;}
   | tm STAR f {$$=validatetype($1,$3);}
   | tm DIV f   {$$=validatetype($1,$3);}
   ;
f  
   : I {strcpy(storeval,$1);$$=validatevar(storeval);}
   | NO {$$=1;}
   | RNO {$$=2;}
   | OPENBRACE exp CLOSEBRACE {$$=$2;}
   ;
read
   : READ OPENBRACE line CLOSEBRACE 
   ;
write
   : WRITE OPENBRACE line CLOSEBRACE
   ;
for 
   : FOR indexexp DO body
   ;
indexexp
   : I EQUAL exp TO exp {strcpy(storeval,$1);$$=validatevar($1);checktype($3,$5);checktype($1,$3);}
   ;
body
   : stm
   | BN sl END
   ;
line
   : I {strcpy(storeval,$1);$$=validatevar($1);}
   | line COMMA I {strcpy(storeval,$3);$$=validatevar($3);}
   ;
%%


// SandC function checks if a variable is defined multiple times or else stores in block table array of identifiers
void SandC(char k[20],int type)
{
int i;
 for(i=0;i<countvar;i++)
 {
     if(strcmp(table[i].val,k)==0)
    {
       fprintf(yyout,"\nCHECK LINE NO:%d --> ERROR: Multiple declarations of variable %s",yylineno,k);
        break;
    }
 
 }
 // we are storing the identifier and it's type in the table
 if(i==countvar)
    {
       strcpy(table[i].val,k);
       table[i].tval=type;
       //printf("%d %s",table[i].tval,table[i].val);
    }
    countvar++;
}

void updatetype(int new)
{ 
//printf("%d ",new);
for(int i=0;i<countvar;i++)
{
if(table[i].tval==0)
{ 
table[i].tval=new;
}
//printf("%d %s\n",table[i].tval,table[i].val);
}
}

// validatevar funtion takes the identifier name to check if the identifier is defined or not and returns the type of identifiers
int  validatevar(char k[20])
{
 int c=0;
 int r=0;
// printf("%s\n",k);
 for(int i=0;i<countvar;i++)
 {
  if(strcmp(table[i].val,k)==0)
  {
   c=1;
   r=table[i].tval;
   break;
  }
  
 }
 // if the identifier is not present in the table
 if(c==0)
 {
  fprintf(yyout,"\nCHECK LINE NO:%d --> ERROR: Undeclared Variable %s",yylineno,k);
  return 0;
 }
 return r;
}

// checktype funtion checks if the arthimetic operation or expression valide according to type on which operations are performed
void checktype(int x,int y)
{
 if(x==0 || y==0)
 {
 // return 0;
  }
  if(y==3)
 {
 fprintf(yyout,"\nCHECK LINE NO:%d --> ERROR: Arthimetic operaton on real and int",yylineno-1);
 }
 if(x==1&&y==2)
 {
  fprintf(yyout,"\nCHECK LINE NO:%d --> ERROR: Implicit conversion of Int type to Real",yylineno);
 }
 if(x==2&&y==1)
 {
  fprintf(yyout,"\nCHECK LINE NO:%d --> ERROR: Implicit conversion of Real type to Int",yylineno);
 }
 return;
}

// validatetype checks if the operaton between the two variables with types x, y is correct or not ,and return 3 if it's not correct
int validatetype(int x,int y)
{
 if(x==0||y==0)
 {
  return 0;
 }
 if(x==y)
 {
 return x;
 }
 // this is for variables of different types
 if(x!=y)
 {
 return 3;
 }
}

extern FILE* yyin;
//#include "lex.yy.c"
int main(int argc, char* argv[])
{
         //WE ARE TAKING THE INPUT FILE THROUGH COMMAND LINE TO PARSE
         yyin = fopen(argv[1], "r");
         yyout= fopen("output.txt","w");
         //IF INPUT FILE IS NOT GIVEN
         if(!yyin)
         {
             fprintf(stderr, "can't read file %s\n", argv[1]);
             return 1;
         }
        // yyparse() FUNCTION PARSES THE GIVEN INPUT FILE
        yyparse();
 return 0;
}

// This is for detecting Syntax Errors 
void yyerror(char* s)
{
//fprintf(stderr,"%s Error\n",s);
}


   
   
   
   
